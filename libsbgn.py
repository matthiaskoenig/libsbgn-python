#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Apr 20 18:58:07 2015 by generateDS.py version 2.15a.
#
# Command line options:
#   ('-o', 'libsbgn.py')
#   ('-s', 'libsbgnSubs.py')
#
# Command line arguments:
#   SBGN.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -o "libsbgn.py" -s "libsbgnSubs.py" SBGN.xsd
#
# Current working directory (os.getcwd()):
#   generateDS
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_

from libsbgnTypes import Language, GlyphClass, ArcClass, Orientation


Validate_simpletypes_ = True


def parsexml_(*args, **kwargs):
    if 'parser' not in kwargs:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class SBGNBase(GeneratedsSuper):
    """The SBGNBase type is the base type of all main components in SBGN.
    It supports attaching metadata, notes and annotations to
    components."""
    subclass = None
    superclass = None
    def __init__(self, notes=None, extension=None, extensiontype_=None):
        self.original_tagname_ = None
        self.notes = notes
        self.extension = extension
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SBGNBase.subclass:
            return SBGNBase.subclass(*args_, **kwargs_)
        else:
            return SBGNBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.notes is not None or
            self.extension is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='SBGNBase', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SBGNBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='SBGNBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='SBGNBase'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='SBGNBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            self.notes.export(outfile, level, namespace_, name_='notes', pretty_print=pretty_print)
        if self.extension is not None:
            self.extension.export(outfile, level, namespace_, name_='extension', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SBGNBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.notesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('extension=model_.extensionType(\n')
            self.extension.exportLiteral(outfile, level, name_='extension')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            obj_ = notesType.factory()
            obj_.build(child_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'extension':
            obj_ = extensionType.factory()
            obj_.build(child_)
            self.extension = obj_
            obj_.original_tagname_ = 'extension'
# end class SBGNBase


class point(SBGNBase):
    """The point element is characterized by PointAttributes, which
    describe absolute 2D cartesian coordinates. Namely: x
    (horizontal, from left to right), y (vertical, from top to
    bottom). The origin is located in the top-left corner of the
    map. There is no unit: proportions must be preserved, but the
    maps can be drawn at any scale. In the test files examples, to
    obtain a drawing similar to the reference *.png file, values in
    the corresponding *.sbgn file should be read as pixels."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, y=None, x=None):
        self.original_tagname_ = None
        super(point, self).__init__(notes, extension, )
        self.y = _cast(float, y)
        self.x = _cast(float, x)
    def factory(*args_, **kwargs_):
        if point.subclass:
            return point.subclass(*args_, **kwargs_)
        else:
            return point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def hasContent_(self):
        if (
            super(point, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='point', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='point')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='point', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='point'):
        super(point, self).exportAttributes(outfile, level, already_processed, namespace_, name_='point')
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_float(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_float(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='point', fromsubclass_=False, pretty_print=True):
        super(point, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='point'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % (self.x,))
        super(point, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(point, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        super(point, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(point, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class point


class bbox(SBGNBase):
    """The bbox element describes a rectangle. This rectangle is defined
    by: PointAttributes corresponding to the 2D coordinates of the
    top left corner, width and height attributes. The rectangle
    corresponds to the outer bounding box of a shape. The shape
    itself can be irregular (for instance in the case of some
    compartments). In the case of process nodes, the bounding box
    only concerns the central glyph (square, or circle), the
    input/output ports are not included, and neither are the lines
    connecting them to the central glyph. A bbox is required for all
    glyphs, and is optional for labels."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, x=None, y=None, w=None,  h=None, notes=None, extension=None):
        self.original_tagname_ = None
        super(bbox, self).__init__(notes, extension, )
        self.y = _cast(float, y)
        self.h = _cast(float, h)
        self.w = _cast(float, w)
        self.x = _cast(float, x)
    def factory(*args_, **kwargs_):
        if bbox.subclass:
            return bbox.subclass(*args_, **kwargs_)
        else:
            return bbox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_h(self): return self.h
    def set_h(self, h): self.h = h
    def get_w(self): return self.w
    def set_w(self, w): self.w = w
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def hasContent_(self):
        if (
            super(bbox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='bbox', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bbox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='bbox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='bbox'):
        super(bbox, self).exportAttributes(outfile, level, already_processed, namespace_, name_='bbox')
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
        if self.w is not None and 'w' not in already_processed:
            already_processed.add('w')
            outfile.write(' w="%s"' % self.gds_format_integer(self.w, input_name='w'))        
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            outfile.write(' h="%s"' % self.gds_format_integer(self.h, input_name='h'))        
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='bbox', fromsubclass_=False, pretty_print=True):
        super(bbox, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='bbox'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % (self.y,))
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            showIndent(outfile, level)
            outfile.write('h=%f,\n' % (self.h,))
        if self.w is not None and 'w' not in already_processed:
            already_processed.add('w')
            showIndent(outfile, level)
            outfile.write('w=%f,\n' % (self.w,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % (self.x,))
        super(bbox, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(bbox, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('h', node)
        if value is not None and 'h' not in already_processed:
            already_processed.add('h')
            try:
                self.h = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (h): %s' % exp)
        value = find_attr_value_('w', node)
        if value is not None and 'w' not in already_processed:
            already_processed.add('w')
            try:
                self.w = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (w): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        super(bbox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(bbox, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class bbox


class label(SBGNBase):
    """The label element describes the text accompanying a glyph. The text
    attribute is mandatory. Its position can be specified by a bbox
    (optional). Tools are free to display the text in any style
    (font, font-size, etc.) The bbox element of a label is optional.
    When no bbox is defined, the bbox of the parent glyph is
    inherited. The label should be drawn centered horizontally and
    vertically in the bbox. When the bbox is inherited, the label
    can freely spill outside (just like it can spill outside its
    parent glyph). An explicit bbox provides a stronger hint
    regarding what surface the label should cover. It defines an
    upper boundary outside of which the label should (ideally) not
    spill. It also represents a preferred size: the surface covered
    by the label can be smaller, but should ideally be as close as
    possible to the bbox. In most glyphs (EPNs, unit of information,
    etc.), the label is supposed to be centered, so the bbox is
    usually omitted (unless there's a specific hint to be shared
    concerning the area the label should ideally cover). However,
    labels can be drawn anywhere inside compartments or complex, so
    these should preferably have an explicit bbox. Multi-line labels
    are allowed. Line breaks are encoded as &#xA; as specified by
    the XML standard."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, text=None, bbox=None):
        self.original_tagname_ = None
        super(label, self).__init__(notes, extension, )
        self.text = _cast(None, text)
        self.bbox = bbox
    def factory(*args_, **kwargs_):
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bbox(self): return self.bbox
    def set_bbox(self, bbox): self.bbox = bbox
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def hasContent_(self):
        if (
            self.bbox is not None or
            super(label, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='label', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='label'):
        super(label, self).exportAttributes(outfile, level, already_processed, namespace_, name_='label')
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_format_string(quote_attrib(self.text).encode(ExternalEncoding), input_name='text'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='label', fromsubclass_=False, pretty_print=True):
        super(label, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bbox is not None:
            self.bbox.export(outfile, level, namespace_='sbgn:', name_='bbox', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='label'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            showIndent(outfile, level)
            outfile.write('text="%s",\n' % (self.text,))
        super(label, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(label, self).exportLiteralChildren(outfile, level, name_)
        if self.bbox is not None:
            showIndent(outfile, level)
            outfile.write('bbox=model_.bbox(\n')
            self.bbox.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
        super(label, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bbox':
            obj_ = bbox.factory()
            obj_.build(child_)
            self.bbox = obj_
            obj_.original_tagname_ = 'bbox'
        super(label, self).buildChildren(child_, node, nodeName_, True)
# end class label


class sbgn(SBGNBase):
    """The sbgn element is the root of any SBGNML document. Currently each
    document must contain exactly one map element."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, map=None):
        self.original_tagname_ = None
        super(sbgn, self).__init__(notes, extension, )
        self.map = map
    def factory(*args_, **kwargs_):
        if sbgn.subclass:
            return sbgn.subclass(*args_, **kwargs_)
        else:
            return sbgn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_map(self): return self.map
    def set_map(self, map): self.map = map
    def hasContent_(self):
        if (
            self.map is not None or
            super(sbgn, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='sbgn', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sbgn')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='sbgn', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='sbgn'):
        super(sbgn, self).exportAttributes(outfile, level, already_processed, namespace_, name_='sbgn')
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='sbgn', fromsubclass_=False, pretty_print=True):
        super(sbgn, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.map is not None:
            self.map.export(outfile, level, namespace_='sbgn:', name_='map', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='sbgn'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(sbgn, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sbgn, self).exportLiteralChildren(outfile, level, name_)
        if self.map is not None:
            showIndent(outfile, level)
            outfile.write('map=model_.map(\n')
            self.map.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(sbgn, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'map':
            obj_ = map.factory()
            obj_.build(child_)
            self.map = obj_
            obj_.original_tagname_ = 'map'
        super(sbgn, self).buildChildren(child_, node, nodeName_, True)
# end class sbgn


class map(SBGNBase):
    """The map element describes a single SBGN PD map. It contains a list
    of glyph elements and a list of arc elements. These lists can be
    of any size (possibly empty). Language of the map: one of three
    sublanguages defined by SBGN. Different languages have different
    restrictions on the usage of sub-elements (that are not encoded
    in this schema but must be validated with an external validator)"""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, language=None, bbox=None, glyph=None, arc=None, arcgroup=None):
        self.original_tagname_ = None
        super(map, self).__init__(notes, extension, )
        self.language = _cast(None, language)
        self.bbox = bbox
        if glyph is None:
            self.glyph = []
        else:
            self.glyph = glyph
        if arc is None:
            self.arc = []
        else:
            self.arc = arc
        if arcgroup is None:
            self.arcgroup = []
        else:
            self.arcgroup = arcgroup
    def factory(*args_, **kwargs_):
        if map.subclass:
            return map.subclass(*args_, **kwargs_)
        else:
            return map(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bbox(self): return self.bbox
    def set_bbox(self, bbox): self.bbox = bbox
    def get_glyph(self): return self.glyph
    def set_glyph(self, glyph): self.glyph = glyph
    def add_glyph(self, value): self.glyph.append(value)
    def insert_glyph_at(self, index, value): self.glyph.insert(index, value)
    def replace_glyph_at(self, index, value): self.glyph[index] = value
    def get_arc(self): return self.arc
    def set_arc(self, arc): self.arc = arc
    def add_arc(self, value): self.arc.append(value)
    def insert_arc_at(self, index, value): self.arc.insert(index, value)
    def replace_arc_at(self, index, value): self.arc[index] = value
    def get_arcgroup(self): return self.arcgroup
    def set_arcgroup(self, arcgroup): self.arcgroup = arcgroup
    def add_arcgroup(self, value): self.arcgroup.append(value)
    def insert_arcgroup_at(self, index, value): self.arcgroup.insert(index, value)
    def replace_arcgroup_at(self, index, value): self.arcgroup[index] = value
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def hasContent_(self):
        if (
            self.bbox is not None or
            self.glyph or
            self.arc or
            self.arcgroup or
            super(map, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='map', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='map')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='map', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='map'):
        super(map, self).exportAttributes(outfile, level, already_processed, namespace_, name_='map')
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_format_string(quote_attrib(self.language).encode(ExternalEncoding), input_name='language'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='map', fromsubclass_=False, pretty_print=True):
        super(map, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bbox is not None:
            self.bbox.export(outfile, level, namespace_='sbgn:', name_='bbox', pretty_print=pretty_print)
        for glyph_ in self.glyph:
            glyph_.export(outfile, level, namespace_='sbgn:', name_='glyph', pretty_print=pretty_print)
        for arc_ in self.arc:
            arc_.export(outfile, level, namespace_='sbgn:', name_='arc', pretty_print=pretty_print)
        for arcgroup_ in self.arcgroup:
            arcgroup_.export(outfile, level, namespace_='sbgn:', name_='arcgroup', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='map'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            showIndent(outfile, level)
            outfile.write('language="%s",\n' % (self.language,))
        super(map, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(map, self).exportLiteralChildren(outfile, level, name_)
        if self.bbox is not None:
            showIndent(outfile, level)
            outfile.write('bbox=model_.bbox(\n')
            self.bbox.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('glyph=[\n')
        level += 1
        for glyph_ in self.glyph:
            showIndent(outfile, level)
            outfile.write('model_.glyph(\n')
            glyph_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('arc=[\n')
        level += 1
        for arc_ in self.arc:
            showIndent(outfile, level)
            outfile.write('model_.arc(\n')
            arc_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('arcgroup=[\n')
        level += 1
        for arcgroup_ in self.arcgroup:
            showIndent(outfile, level)
            outfile.write('model_.arcgroup(\n')
            arcgroup_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        super(map, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bbox':
            obj_ = bbox.factory()
            obj_.build(child_)
            self.bbox = obj_
            obj_.original_tagname_ = 'bbox'
        elif nodeName_ == 'glyph':
            obj_ = glyph.factory()
            obj_.build(child_)
            self.glyph.append(obj_)
            obj_.original_tagname_ = 'glyph'
        elif nodeName_ == 'arc':
            obj_ = arc.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'arc'
        elif nodeName_ == 'arcgroup':
            obj_ = arcgroup.factory()
            obj_.build(child_)
            self.arcgroup.append(obj_)
            obj_.original_tagname_ = 'arcgroup'
        super(map, self).buildChildren(child_, node, nodeName_, True)
# end class map


class port(SBGNBase):
    """The port element describes an anchor point which arcs can refer to
    as a source or target. It consists in: absolute 2D cartesian
    coordinates (PointAttribute), a unique id attribute. Two port
    elements are required for process nodes. They represent the
    extremity of the two "arms" which protrude on both sides of the
    core of the glyph (= square or circle shape). Other glyphs don't
    need ports (but can use them if desired). The xsd:ID type is an
    alphanumeric identifier, starting with a letter. Port IDs often
    contain the ID of their glyph, followed by a local port number
    (e.g. glyph4.1, glyph4.2, etc.) However, this style convention
    is not mandatory, and IDs should never be interpreted as
    carrying any meaning."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, y=None, x=None, id=None):
        self.original_tagname_ = None
        super(port, self).__init__(notes, extension, )
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if port.subclass:
            return port.subclass(*args_, **kwargs_)
        else:
            return port(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            super(port, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='port', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='port')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='port', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='port'):
        super(port, self).exportAttributes(outfile, level, already_processed, namespace_, name_='port')
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='port', fromsubclass_=False, pretty_print=True):
        super(port, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='port'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % (self.x,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(port, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(port, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(port, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(port, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class port


class glyph(SBGNBase):
    """The glyph element is: either a stand-alone, high-level SBGN glyph
    (EPN, PN, compartment, etc), or a sub-glyph (state variable,
    unit of information, inside of a complex, ...) In the first
    case, it appears directly in the glyph list of the map. In the
    second case, it is a child of another glyph element. The text
    inside a glyph is described: either by a label element
    (optional) [process nodes can't have one], or by a state element
    (optional) [for state variables only]. The class attribute
    defines the semantic of the glyph, and influences: the way that
    glyph should be rendered, the overall syntactic validity of the
    map. The various classes encompass the following PD SBGN
    elements: Entity Pool Nodes (EPN), Process Nodes (PN), Logic
    Operator Nodes, Sub-glyphs on Nodes (State Variable, Unit of
    Information), Sub-glyphs on Arcs (Stoichiometry Label), Other
    glyphs (Compartment, Submap, Tag, Terminal). And the following
    ER SBGN elements Entities (Entity, Outcome) Other (Annotation,
    Phenotype) Auxiliary on glyps (Existence, Location) Auxiliary on
    arcs (Cardinality) Delay operator implicit xor The orientation
    attribute is used to express how to draw asymmetric glyphs. In
    PD, the orientation of Process Nodes is either horizontal or
    vertical. It refers to an (imaginary) line connecting the two
    in/out sides of the PN. In PD, the orientation of Tags and
    Terminals can be left, right, up or down. It refers to the
    direction the arrow side of the glyph is pointing at. The xsd:ID
    type is an alphanumeric identifier, starting with a letter. It
    is recommended to generate meaningless IDs (e.g. "glyph1234")
    and avoid IDs with a meaning (e.g. "epn_ethanol") Reference to
    the ID of the compartment that this glyph is part of. Only use
    this if there is at least one explicit compartment present in
    the diagram. Compartments are only used in PD and AF, and thus
    this attribute as well. For PD, this should be used only for
    EPN's. In case there are no compartments, entities that can have
    a location, such as EPN's, are implicit member of an invisible
    compartment that encompasses the whole map. In that case, this
    attribute must be omitted. The compartment order attribute can
    be used to define a drawing order for compartments. It enables
    tools to draw compartments in the correct order especially in
    the case of overlapping compartments. Compartments are only used
    in PD and AF, and thus this attribute as well. The attribute is
    of type float, the attribute value has not to be unique.
    Compartments with higher compartment order are drawn on top. The
    attribute is optional and should only be used for compartments."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, id=None, compartmentRef=None, class_=None, compartmentOrder=None, orientation=Orientation.HORIZONTAL, 
                 label=None, state=None, clone=None, callout=None, entity=None, bbox=None, glyph_member=None, port=None):
        self.original_tagname_ = None
        super(glyph, self).__init__(notes, extension, )
        self.id = _cast(None, id)
        self.compartmentRef = _cast(None, compartmentRef)
        if class_ and not isinstance(class_, GlyphClass):
            raise TypeError('class must be of type GlyphClass')
        if class_:
            self.class_ = _cast(None, class_.value)
        else:
            self.class_ = _cast(None, class_)
        self.compartmentOrder = _cast(float, compartmentOrder)
        if not isinstance(orientation, Orientation):
            raise TypeError('orientation must be of type Orientation')
        self.orientation = _cast(None, orientation.value)
        self.label = label
        self.state = state
        self.clone = clone
        self.callout = callout
        self.entity = entity
        self.bbox = bbox
        if glyph_member is None:
            self.glyph = []
        else:
            self.glyph = glyph_member
        if port is None:
            self.port = []
        else:
            self.port = port
    def factory(*args_, **kwargs_):
        if glyph.subclass:
            return glyph.subclass(*args_, **kwargs_)
        else:
            return glyph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_clone(self): return self.clone
    def set_clone(self, clone): self.clone = clone
    def get_callout(self): return self.callout
    def set_callout(self, callout): self.callout = callout
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_bbox(self): return self.bbox
    def set_bbox(self, bbox): self.bbox = bbox
    def get_glyph(self): return self.glyph
    def set_glyph(self, glyph): self.glyph = glyph
    def add_glyph(self, value): self.glyph.append(value)
    def insert_glyph_at(self, index, value): self.glyph.insert(index, value)
    def replace_glyph_at(self, index, value): self.glyph[index] = value
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def add_port(self, value): self.port.append(value)
    def insert_port_at(self, index, value): self.port.insert(index, value)
    def replace_port_at(self, index, value): self.port[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_compartmentRef(self): return self.compartmentRef
    def set_compartmentRef(self, compartmentRef): self.compartmentRef = compartmentRef
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_compartmentOrder(self): return self.compartmentOrder
    def set_compartmentOrder(self, compartmentOrder): self.compartmentOrder = compartmentOrder
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def hasContent_(self):
        if (
            self.label is not None or
            self.state is not None or
            self.clone is not None or
            self.callout is not None or
            self.entity is not None or
            self.bbox is not None or
            self.glyph or
            self.port or
            super(glyph, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='glyph', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='glyph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='glyph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='glyph'):
        super(glyph, self).exportAttributes(outfile, level, already_processed, namespace_, name_='glyph')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.compartmentRef is not None and 'compartmentRef' not in already_processed:
            already_processed.add('compartmentRef')
            outfile.write(' compartmentRef=%s' % (self.gds_format_string(quote_attrib(self.compartmentRef).encode(ExternalEncoding), input_name='compartmentRef'), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.class_).encode(ExternalEncoding), input_name='class'), ))
        if self.compartmentOrder is not None and 'compartmentOrder' not in already_processed:
            already_processed.add('compartmentOrder')
            outfile.write(' compartmentOrder="%s"' % self.gds_format_float(self.compartmentOrder, input_name='compartmentOrder'))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_format_string(quote_attrib(self.orientation).encode(ExternalEncoding), input_name='orientation'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='glyph', fromsubclass_=False, pretty_print=True):
        super(glyph, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.label is not None:
            self.label.export(outfile, level, namespace_='sbgn:', name_='label', pretty_print=pretty_print)
        if self.state is not None:
            self.state.export(outfile, level, namespace_, name_='state', pretty_print=pretty_print)
        if self.clone is not None:
            self.clone.export(outfile, level, namespace_, name_='clone', pretty_print=pretty_print)
        if self.callout is not None:
            self.callout.export(outfile, level, namespace_, name_='callout', pretty_print=pretty_print)
        if self.entity is not None:
            self.entity.export(outfile, level, namespace_, name_='entity', pretty_print=pretty_print)
        if self.bbox is not None:
            self.bbox.export(outfile, level, namespace_='sbgn:', name_='bbox', pretty_print=pretty_print)
        for glyph_ in self.glyph:
            glyph_.export(outfile, level, namespace_='sbgn:', name_='glyph', pretty_print=pretty_print)
        for port_ in self.port:
            port_.export(outfile, level, namespace_='sbgn:', name_='port', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='glyph'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.compartmentRef is not None and 'compartmentRef' not in already_processed:
            already_processed.add('compartmentRef')
            showIndent(outfile, level)
            outfile.write('compartmentRef="%s",\n' % (self.compartmentRef,))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            showIndent(outfile, level)
            outfile.write('class_="%s",\n' % (self.class_,))
        if self.compartmentOrder is not None and 'compartmentOrder' not in already_processed:
            already_processed.add('compartmentOrder')
            showIndent(outfile, level)
            outfile.write('compartmentOrder=%f,\n' % (self.compartmentOrder,))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            showIndent(outfile, level)
            outfile.write('orientation="%s",\n' % (self.orientation,))
        super(glyph, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(glyph, self).exportLiteralChildren(outfile, level, name_)
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label=model_.label(\n')
            self.label.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state=model_.stateType(\n')
            self.state.exportLiteral(outfile, level, name_='state')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.clone is not None:
            showIndent(outfile, level)
            outfile.write('clone=model_.cloneType(\n')
            self.clone.exportLiteral(outfile, level, name_='clone')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.callout is not None:
            showIndent(outfile, level)
            outfile.write('callout=model_.calloutType(\n')
            self.callout.exportLiteral(outfile, level, name_='callout')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.entity is not None:
            showIndent(outfile, level)
            outfile.write('entity=model_.entityType(\n')
            self.entity.exportLiteral(outfile, level, name_='entity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bbox is not None:
            showIndent(outfile, level)
            outfile.write('bbox=model_.bbox(\n')
            self.bbox.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('glyph=[\n')
        level += 1
        for glyph_ in self.glyph:
            showIndent(outfile, level)
            outfile.write('model_.glyph(\n')
            glyph_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('port=[\n')
        level += 1
        for port_ in self.port:
            showIndent(outfile, level)
            outfile.write('model_.port(\n')
            port_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('compartmentRef', node)
        if value is not None and 'compartmentRef' not in already_processed:
            already_processed.add('compartmentRef')
            self.compartmentRef = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('compartmentOrder', node)
        if value is not None and 'compartmentOrder' not in already_processed:
            already_processed.add('compartmentOrder')
            try:
                self.compartmentOrder = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (compartmentOrder): %s' % exp)
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
        super(glyph, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'state':
            obj_ = stateType.factory()
            obj_.build(child_)
            self.state = obj_
            obj_.original_tagname_ = 'state'
        elif nodeName_ == 'clone':
            obj_ = cloneType.factory()
            obj_.build(child_)
            self.clone = obj_
            obj_.original_tagname_ = 'clone'
        elif nodeName_ == 'callout':
            obj_ = calloutType.factory()
            obj_.build(child_)
            self.callout = obj_
            obj_.original_tagname_ = 'callout'
        elif nodeName_ == 'entity':
            obj_ = entityType.factory()
            obj_.build(child_)
            self.entity = obj_
            obj_.original_tagname_ = 'entity'
        elif nodeName_ == 'bbox':
            obj_ = bbox.factory()
            obj_.build(child_)
            self.bbox = obj_
            obj_.original_tagname_ = 'bbox'
        elif nodeName_ == 'glyph':
            obj_ = glyph.factory()
            obj_.build(child_)
            self.glyph.append(obj_)
            obj_.original_tagname_ = 'glyph'
        elif nodeName_ == 'port':
            obj_ = port.factory()
            obj_.build(child_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
        super(glyph, self).buildChildren(child_, node, nodeName_, True)
# end class glyph


class arcgroup(SBGNBase):
    """The arc group describes a set of arcs and glyphs that together have
    a relation. For example For ER: interaction arcs around an
    interaction glyph, ... Note that, in spite of the name, an
    arcgroup contains both arcs and glyphs. The class attribute
    defines the semantic of the arcgroup."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, class_=None, glyph=None, arc=None):
        self.original_tagname_ = None
        super(arcgroup, self).__init__(notes, extension, )
        self.class_ = _cast(None, class_)
        if glyph is None:
            self.glyph = []
        else:
            self.glyph = glyph
        if arc is None:
            self.arc = []
        else:
            self.arc = arc
    def factory(*args_, **kwargs_):
        if arcgroup.subclass:
            return arcgroup.subclass(*args_, **kwargs_)
        else:
            return arcgroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_glyph(self): return self.glyph
    def set_glyph(self, glyph): self.glyph = glyph
    def add_glyph(self, value): self.glyph.append(value)
    def insert_glyph_at(self, index, value): self.glyph.insert(index, value)
    def replace_glyph_at(self, index, value): self.glyph[index] = value
    def get_arc(self): return self.arc
    def set_arc(self, arc): self.arc = arc
    def add_arc(self, value): self.arc.append(value)
    def insert_arc_at(self, index, value): self.arc.insert(index, value)
    def replace_arc_at(self, index, value): self.arc[index] = value
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.glyph or
            self.arc or
            super(arcgroup, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='arcgroup', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arcgroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='arcgroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='arcgroup'):
        super(arcgroup, self).exportAttributes(outfile, level, already_processed, namespace_, name_='arcgroup')
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.class_).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='arcgroup', fromsubclass_=False, pretty_print=True):
        super(arcgroup, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for glyph_ in self.glyph:
            glyph_.export(outfile, level, namespace_='sbgn:', name_='glyph', pretty_print=pretty_print)
        for arc_ in self.arc:
            arc_.export(outfile, level, namespace_='sbgn:', name_='arc', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='arcgroup'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            showIndent(outfile, level)
            outfile.write('class_="%s",\n' % (self.class_,))
        super(arcgroup, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(arcgroup, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('glyph=[\n')
        level += 1
        for glyph_ in self.glyph:
            showIndent(outfile, level)
            outfile.write('model_.glyph(\n')
            glyph_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('arc=[\n')
        level += 1
        for arc_ in self.arc:
            showIndent(outfile, level)
            outfile.write('model_.arc(\n')
            arc_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        super(arcgroup, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'glyph':
            obj_ = glyph.factory()
            obj_.build(child_)
            self.glyph.append(obj_)
            obj_.original_tagname_ = 'glyph'
        elif nodeName_ == 'arc':
            obj_ = arc.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'arc'
        super(arcgroup, self).buildChildren(child_, node, nodeName_, True)
# end class arcgroup


class arc(SBGNBase):
    """The arc element describes an SBGN arc between two SBGN nodes. It
    contains: For PD: an optional stoichiometry marker, For ER: an
    optional cardinality marker, zero or more ports (influence
    targets), and zero or more outcomes, a mandatory source and
    target (glyph or port), a geometric description of its whole
    path, from start to end. This path can involve any number of
    straight lines or quadratic/cubic Bezier curves. The class
    attribute defines the semantic of the arc, and influences: the
    way that arc should be rendered, the overall syntactic validity
    of the map. The various classes encompass all possible types of
    SBGN arcs: production and consumption arcs, all types of
    modification arcs, logic arcs, equivalence arcs. To express a
    reversible reaction, use production arcs on both sides of the
    Process Node. The xsd:ID type is an alphanumeric identifier,
    starting with a letter. The source attribute can refer: either
    to the id of a glyph, or to the id of a port on a glyph. The
    target attribute can refer: either to the id of a glyph, or to
    the id of a port on a glyph."""
    subclass = None
    superclass = SBGNBase
    def __init__(self, notes=None, extension=None, source=None, target=None, class_=None, id=None, glyph=None, port=None, start=None, next=None, end=None):
        self.original_tagname_ = None
        super(arc, self).__init__(notes, extension, )
        self.source = _cast(None, source)
        self.target = _cast(None, target)
        if class_ and not isinstance(class_, ArcClass):
            raise TypeError('class must be of type ArcClass')
        if class_:
            self.class_ = _cast(None, class_.value)
        else:
            self.class_ = _cast(None, class_)
        self.id = _cast(None, id)
        if glyph is None:
            self.glyph = []
        else:
            self.glyph = glyph
        if port is None:
            self.port = []
        else:
            self.port = port
        self.start = start
        if next is None:
            self.next = []
        else:
            self.next = next
        self.end = end
    def factory(*args_, **kwargs_):
        if arc.subclass:
            return arc.subclass(*args_, **kwargs_)
        else:
            return arc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_glyph(self): return self.glyph
    def set_glyph(self, glyph): self.glyph = glyph
    def add_glyph(self, value): self.glyph.append(value)
    def insert_glyph_at(self, index, value): self.glyph.insert(index, value)
    def replace_glyph_at(self, index, value): self.glyph[index] = value
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def add_port(self, value): self.port.append(value)
    def insert_port_at(self, index, value): self.port.insert(index, value)
    def replace_port_at(self, index, value): self.port[index] = value
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_next(self): return self.next
    def set_next(self, next): self.next = next
    def add_next(self, value): self.next.append(value)
    def insert_next_at(self, index, value): self.next.insert(index, value)
    def replace_next_at(self, index, value): self.next[index] = value
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.glyph or
            self.port or
            self.start is not None or
            self.next or
            self.end is not None or
            super(arc, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='arc', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='arc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='arc'):
        super(arc, self).exportAttributes(outfile, level, already_processed, namespace_, name_='arc')
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding), input_name='source'), ))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.class_).encode(ExternalEncoding), input_name='class'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='arc', fromsubclass_=False, pretty_print=True):
        super(arc, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for glyph_ in self.glyph:
            glyph_.export(outfile, level, namespace_='sbgn:', name_='glyph', pretty_print=pretty_print)
        for port_ in self.port:
            port_.export(outfile, level, namespace_='sbgn:', name_='port', pretty_print=pretty_print)
        if self.start is not None:
            self.start.export(outfile, level, namespace_, name_='start', pretty_print=pretty_print)
        for next_ in self.next:
            next_.export(outfile, level, namespace_, name_='next', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, namespace_, name_='end', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='arc'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            showIndent(outfile, level)
            outfile.write('source="%s",\n' % (self.source,))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            showIndent(outfile, level)
            outfile.write('target="%s",\n' % (self.target,))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            showIndent(outfile, level)
            outfile.write('class_="%s",\n' % (self.class_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(arc, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(arc, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('glyph=[\n')
        level += 1
        for glyph_ in self.glyph:
            showIndent(outfile, level)
            outfile.write('model_.glyph(\n')
            glyph_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('port=[\n')
        level += 1
        for port_ in self.port:
            showIndent(outfile, level)
            outfile.write('model_.port(\n')
            port_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.start is not None:
            showIndent(outfile, level)
            outfile.write('start=model_.startType(\n')
            self.start.exportLiteral(outfile, level, name_='start')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('next=[\n')
        level += 1
        for next_ in self.next:
            showIndent(outfile, level)
            outfile.write('model_.nextType(\n')
            next_.exportLiteral(outfile, level, name_='nextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.endType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(arc, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'glyph':
            obj_ = glyph.factory()
            obj_.build(child_)
            self.glyph.append(obj_)
            obj_.original_tagname_ = 'glyph'
        elif nodeName_ == 'port':
            obj_ = port.factory()
            obj_.build(child_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
        elif nodeName_ == 'start':
            obj_ = startType.factory()
            obj_.build(child_)
            self.start = obj_
            obj_.original_tagname_ = 'start'
        elif nodeName_ == 'next':
            obj_ = nextType.factory()
            obj_.build(child_)
            self.next.append(obj_)
            obj_.original_tagname_ = 'next'
        elif nodeName_ == 'end':
            obj_ = endType.factory()
            obj_.build(child_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        super(arc, self).buildChildren(child_, node, nodeName_, True)
# end class arc


class notesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if notesType.subclass:
            return notesType.subclass(*args_, **kwargs_)
        else:
            return notesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='notesType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='notesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='notesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='notesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='notesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='notesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'notesType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class notesType


class extensionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if extensionType.subclass:
            return extensionType.subclass(*args_, **kwargs_)
        else:
            return extensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='extensionType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='extensionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='extensionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='extensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='extensionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'extensionType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class extensionType


class stateType(GeneratedsSuper):
    """The value attribute represents the state of the variable. It can be:
    either from a predefined set of string (P, S, etc.) which
    correspond to specific SBO terms (cf. SBGN specs), or any
    arbitrary string. The variable attribute describes the site
    where the modification described by the value attribute occurs.
    It is: optional when there is only one state variable on the
    parent EPN, required when there is more than one state variable
    the parent EPN."""
    subclass = None
    superclass = None
    def __init__(self, variable=None, value=None):
        self.original_tagname_ = None
        self.variable = _cast(None, variable)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if stateType.subclass:
            return stateType.subclass(*args_, **kwargs_)
        else:
            return stateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='stateType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='stateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='stateType'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.add('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='stateType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='stateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.add('variable')
            showIndent(outfile, level)
            outfile.write('variable="%s",\n' % (self.variable,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.add('variable')
            self.variable = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stateType


class cloneType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, label=None):
        self.original_tagname_ = None
        self.label = label
    def factory(*args_, **kwargs_):
        if cloneType.subclass:
            return cloneType.subclass(*args_, **kwargs_)
        else:
            return cloneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def hasContent_(self):
        if (
            self.label is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='cloneType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cloneType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='cloneType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='cloneType'):
        pass
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='cloneType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.label is not None:
            self.label.export(outfile, level, namespace_='sbgn:', name_='label', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cloneType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label=model_.label(\n')
            self.label.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
# end class cloneType


class calloutType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, target=None, point=None):
        self.original_tagname_ = None
        self.target = _cast(None, target)
        self.point = point
    def factory(*args_, **kwargs_):
        if calloutType.subclass:
            return calloutType.subclass(*args_, **kwargs_)
        else:
            return calloutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_point(self): return self.point
    def set_point(self, point): self.point = point
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def hasContent_(self):
        if (
            self.point is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='calloutType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='calloutType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='calloutType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='calloutType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='calloutType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.point is not None:
            self.point.export(outfile, level, namespace_='sbgn:', name_='point', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='calloutType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            showIndent(outfile, level)
            outfile.write('target="%s",\n' % (self.target,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.point is not None:
            showIndent(outfile, level)
            outfile.write('point=model_.point(\n')
            self.point.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = point.factory()
            obj_.build(child_)
            self.point = obj_
            obj_.original_tagname_ = 'point'
# end class calloutType


class entityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if entityType.subclass:
            return entityType.subclass(*args_, **kwargs_)
        else:
            return entityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='entityType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='entityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='entityType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='entityType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='entityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class entityType


class startType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None):
        self.original_tagname_ = None
        self.y = _cast(float, y)
        self.x = _cast(float, x)
    def factory(*args_, **kwargs_):
        if startType.subclass:
            return startType.subclass(*args_, **kwargs_)
        else:
            return startType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='startType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='startType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='startType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='startType'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='startType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='startType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class startType


class nextType(GeneratedsSuper):
    """List of control points, used when the path describes a curve. The
    number of points describes the degree of the Bezier curve:
    linear (0), quadratic (1) or cubic (2)"""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, point=None):
        self.original_tagname_ = None
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        if point is None:
            self.point = []
        else:
            self.point = point
    def factory(*args_, **kwargs_):
        if nextType.subclass:
            return nextType.subclass(*args_, **kwargs_)
        else:
            return nextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_point(self): return self.point
    def set_point(self, point): self.point = point
    def add_point(self, value): self.point.append(value)
    def insert_point_at(self, index, value): self.point.insert(index, value)
    def replace_point_at(self, index, value): self.point[index] = value
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def hasContent_(self):
        if (
            self.point
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='nextType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nextType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='nextType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='nextType'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='nextType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for point_ in self.point:
            point_.export(outfile, level, namespace_='sbgn:', name_='point', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='nextType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('point=[\n')
        level += 1
        for point_ in self.point:
            showIndent(outfile, level)
            outfile.write('model_.point(\n')
            point_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = point.factory()
            obj_.build(child_)
            self.point.append(obj_)
            obj_.original_tagname_ = 'point'
# end class nextType


class endType(GeneratedsSuper):
    """List of control points, used when the path describes a curve. The
    number of points describes the degree of the Bezier curve:
    linear (0), quadratic (1) or cubic (2)"""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, point=None):
        self.original_tagname_ = None
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        if point is None:
            self.point = []
        else:
            self.point = point
    def factory(*args_, **kwargs_):
        if endType.subclass:
            return endType.subclass(*args_, **kwargs_)
        else:
            return endType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_point(self): return self.point
    def set_point(self, point): self.point = point
    def add_point(self, value): self.point.append(value)
    def insert_point_at(self, index, value): self.point.insert(index, value)
    def replace_point_at(self, index, value): self.point[index] = value
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def hasContent_(self):
        if (
            self.point
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='sbgn:', name_='endType', namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='endType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='sbgn:', name_='endType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='sbgn:', name_='endType'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
    def exportChildren(self, outfile, level, namespace_='sbgn:', name_='endType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for point_ in self.point:
            point_.export(outfile, level, namespace_='sbgn:', name_='point', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='endType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('point=[\n')
        level += 1
        for point_ in self.point:
            showIndent(outfile, level)
            outfile.write('model_.point(\n')
            point_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = point.factory()
            obj_.build(child_)
            self.point.append(obj_)
            obj_.original_tagname_ = 'point'
# end class endType


GDSClassesMapping = {
    'end': endType,
    'extension': extensionType,
    'clone': cloneType,
    'callout': calloutType,
    'entity': entityType,
    'start': startType,
    'state': stateType,
    'next': nextType,
    'notes': notesType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SBGNBase'
        rootClass = SBGNBase
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SBGNBase'
        rootClass = SBGNBase
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SBGNBase'
        rootClass = SBGNBase
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:sbgn="http://sbgn.org/libsbgn/0.2"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SBGNBase'
        rootClass = SBGNBase
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from libsbgn import *\n\n')
        sys.stdout.write('import libsbgn as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "SBGNBase",
    "arc",
    "arcgroup",
    "bbox",
    "calloutType",
    "cloneType",
    "endType",
    "entityType",
    "extensionType",
    "glyph",
    "label",
    "map",
    "nextType",
    "notesType",
    "point",
    "port",
    "sbgn",
    "startType",
    "stateType"
]
